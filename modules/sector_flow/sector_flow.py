
import akshare as ak
import pandas as pd
import random
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import os
import platform
import requests
from datetime import datetime

# Configure Chinese Font
def get_chinese_font():
    system = platform.system()
    if system == "Windows":
        return "SimHei"
    elif system == "Darwin":
        return "Arial Unicode MS"  # or PingFang SC
    else:
        return "WenQuanYi Micro Hei"

plt.rcParams['font.sans-serif'] = [get_chinese_font()]
plt.rcParams['axes.unicode_minus'] = False


def _fetch_sector_flow_dataapi(sector_type):
    """é€šè¿‡ data.eastmoney.com çš„ä¸­è½¬æ¥å£è·å–æ¿å—èµ„é‡‘æµï¼Œè§„é¿ push2 è¿æ¥é—®é¢˜ã€‚"""
    sector_code_map = {
        'è¡Œä¸šèµ„é‡‘æµ': 'm:90+t:2',
        'æ¦‚å¿µèµ„é‡‘æµ': 'm:90+t:3',
        'åœ°åŸŸèµ„é‡‘æµ': 'm:90+t:1',
    }
    flow_key_map = {'ä»Šæ—¥': 'f62', '5æ—¥': 'f164', '10æ—¥': 'f174'}

    code = sector_code_map.get(sector_type)
    if not code:
        return None

    url = "https://data.eastmoney.com/dataapi/bkzj/getbkzj"
    params = {"key": flow_key_map['ä»Šæ—¥'], "code": code}
    headers = {
        "User-Agent": (
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
            "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
        )
    }
    resp = requests.get(url, params=params, headers=headers, timeout=15)
    resp.raise_for_status()
    payload = resp.json()

    if payload.get("rc") != 0:
        raise RuntimeError(f"DataAPI rc={payload.get('rc')}")

    diff = ((payload.get("data") or {}).get("diff") or [])
    if not diff:
        return None

    df = pd.DataFrame(diff)
    if "f14" not in df.columns or "f62" not in df.columns:
        return None

    df = df.rename(columns={"f14": "åç§°", "f62": "net_flow"})
    df["net_flow_billion"] = pd.to_numeric(df["net_flow"], errors="coerce") / 100000000
    df = df.dropna(subset=["net_flow_billion"])
    if df.empty:
        return None

    return df


def draw_sector_chart(inflow_df, outflow_df, name_col, flow_col, output_dir):
    """
    Draw a vertical 9:16 chart: Sector Power Bar (Inflow vs Outflow)
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir, exist_ok=True)

    # Data Preparation
    # Top 10 Inflow (Red)
    top_in = inflow_df.head(10).copy()
    top_in = top_in.sort_values(by=flow_col, ascending=True) # Sort for horizontal bar (bottom to top)

    # Top 10 Outflow (Green)
    top_out = outflow_df.head(10).copy()
    top_out = top_out.sort_values(by=flow_col, ascending=False) # Sort for horizontal bar (top is largest negative)
    # Ensure outflow is negative for visualization direction if not already?
    # Usually flow_col is signed. Outflow should be negative.

    # Create Figure
    fig = plt.figure(figsize=(10, 17.7), facecolor='#1e1e1e')
    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
    ax.set_facecolor('#1e1e1e')
    ax.axis('off')

    # Title
    date_str = datetime.now().strftime('%Y-%m-%d')
    fig.text(0.5, 0.95, f"æ¿å—èµ„é‡‘æµå‘å¤§æ¯”æ‹¼ ({date_str})",
            ha='center', color='#FFD700', fontsize=24, fontweight='bold')

    # --- Top Panel: Inflow ---
    # 1. Inflow Chart (Top)
    ax_in = fig.add_axes([0.15, 0.55, 0.75, 0.35])
    ax_in.set_facecolor('#1e1e1e')
    ax_in.spines['top'].set_visible(False)
    ax_in.spines['right'].set_visible(False)
    ax_in.spines['bottom'].set_color('#555555')
    ax_in.spines['left'].set_color('#555555')

    bars_in = ax_in.barh(top_in[name_col], top_in[flow_col], color='#ff4d4d')
    ax_in.set_title("ä¸»åŠ›å‡€æµå…¥ Top 10 (äº¿å…ƒ)", color='white', fontsize=16, pad=10)
    ax_in.tick_params(axis='y', colors='white', labelsize=12)
    ax_in.tick_params(axis='x', colors='white')

    # Add labels
    for bar in bars_in:
        width = bar.get_width()
        ax_in.text(width + 0.1, bar.get_y() + bar.get_height()/2,
                   f'{width:.2f}', va='center', color='white', fontsize=10)

    # 2. Outflow Chart (Bottom)
    ax_out = fig.add_axes([0.15, 0.1, 0.75, 0.35])
    ax_out.set_facecolor('#1e1e1e')
    ax_out.spines['top'].set_visible(False)
    ax_out.spines['right'].set_visible(False)
    ax_out.spines['bottom'].set_color('#555555')
    ax_out.spines['left'].set_color('#555555')

    # Make outflow positive for bar length, but color green
    # Assuming flow_col is negative for outflow
    out_values = top_out[flow_col].abs()

    bars_out = ax_out.barh(top_out[name_col], out_values, color='#00cc66')
    ax_out.set_title("ä¸»åŠ›å‡€æµå‡º Top 10 (äº¿å…ƒ)", color='white', fontsize=16, pad=10)
    ax_out.tick_params(axis='y', colors='white', labelsize=12)
    ax_out.tick_params(axis='x', colors='white')

    # Add labels (add negative sign back)
    for bar in bars_out:
        width = bar.get_width()
        ax_out.text(width + 0.1, bar.get_y() + bar.get_height()/2,
                   f'-{width:.2f}', va='center', color='white', fontsize=10)

    # Footer
    fig.text(0.5, 0.02, "Generated by Stock Daily Report", ha='center', color='#555555', fontsize=10)

    # DISABLED: User requested to disable sector_flow.png generation
    # output_path = os.path.join(output_dir, "sector_flow.png")
    # plt.savefig(output_path, dpi=150, bbox_inches='tight', facecolor=fig.get_facecolor())
    plt.close()
    # print(f"Sector Flow chart saved to {output_path}")


def get_sector_flow(sector_type='è¡Œä¸šèµ„é‡‘æµ'):
    """è·å–æ¿å—èµ„é‡‘æµæ’å (è¿”å› Top 10 æµå…¥å’Œ Top 10 æµå‡º)"""
    try:
        print(f"æ­£åœ¨è·å– {sector_type} æ•°æ®...")
        import time
        df = None

        # Plan A: THS (Tonghuashun) - prioritized
        # Plan B: EastMoney (Fallback)

        data_source = "THS"

        # --- THS Implementation ---
        try:
            print(f"å°è¯•æ•°æ®æº: åŒèŠ±é¡º (THS) - {sector_type}...")

            if sector_type == 'æ¦‚å¿µèµ„é‡‘æµ':
                # use Concept API
                df_ths = ak.stock_fund_flow_concept(symbol="å³æ—¶")
                if df_ths is not None and not df_ths.empty:
                    # Cols: åºå·, è¡Œä¸š, è¡Œä¸šæŒ‡æ•°, ..., å‡€é¢, ...
                    # Rename 'è¡Œä¸š' -> 'åç§°', 'å‡€é¢' -> 'net_flow_billion' (Assuming Unit is Yi)
                    df_ths = df_ths.rename(columns={'è¡Œä¸š': 'åç§°', 'å‡€é¢': 'net_flow_billion'})

                    # Ensure numeric
                    df_ths['net_flow_billion'] = pd.to_numeric(df_ths['net_flow_billion'], errors='coerce')

                    # --- Filtering Noise (THS Concept) ---
                    exclude_keywords = [
                        "åŒèŠ±é¡º", "æ¿å—", "æˆåˆ†", "æŒè‚¡", "è‚¡é€š", "åŸºé‡‘", "æ˜¨æ—¥", "äººæ°‘å¸",
                        "èèµ„", "èåˆ¸", "Bè‚¡", "ST", "è½¬å€º", "é«˜è‚¡æ¯", "ç ´å‡€", "ç™¾å…ƒ", "æ ¸å¿ƒ",
                        "é¾™å¤´", "èŒ…", "å¤§ç›˜", "ä¸­å­—å¤´", "AH", "REITs", "ETF", "æ ‡å‡†", "æ™®å°”", "MSCI", "å«Hè‚¡"
                    ]
                    if 'åç§°' in df_ths.columns:
                         df_ths = df_ths[~df_ths['åç§°'].apply(lambda x: any(k in str(x) for k in exclude_keywords))]

                    top_inflow = df_ths.sort_values(by='net_flow_billion', ascending=False).head(10)
                    top_outflow = df_ths.sort_values(by='net_flow_billion', ascending=True).head(10)

                    return top_inflow, top_outflow, 'åç§°', 'net_flow_billion'

            else:
                # Default / Industry API
                df_ths = ak.stock_board_industry_summary_ths()
                if df_ths is not None and not df_ths.empty:
                    # Columns: ['åºå·', 'æ¿å—', 'æ¶¨è·Œå¹…', 'æ€»æˆäº¤é‡', 'æ€»æˆäº¤é¢', 'å‡€æµå…¥', ...]
                    # Renaming for compatibility
                    df_ths = df_ths.rename(columns={'æ¿å—': 'åç§°', 'å‡€æµå…¥': 'net_flow'})

                    # Assume 'net_flow' from THS is already in 'äº¿' (Billions) based on debug.
                    df_ths['net_flow_billion'] = pd.to_numeric(df_ths['net_flow'], errors='coerce')

                    # --- Filtering Noise (THS Industry) ---
                    exclude_keywords = [
                        "åŒèŠ±é¡º", "æ¿å—", "æˆåˆ†", "æŒè‚¡", "è‚¡é€š", "åŸºé‡‘", "æ˜¨æ—¥", "äººæ°‘å¸",
                        "èèµ„", "èåˆ¸", "Bè‚¡", "ST", "è½¬å€º", "é«˜è‚¡æ¯", "ç ´å‡€", "ç™¾å…ƒ", "æ ¸å¿ƒ",
                        "é¾™å¤´", "èŒ…", "å¤§ç›˜", "ä¸­å­—å¤´", "AH", "REITs", "ETF", "æ ‡å‡†", "æ™®å°”", "MSCI", "å«Hè‚¡"
                    ]
                    if 'åç§°' in df_ths.columns:
                         df_ths = df_ths[~df_ths['åç§°'].apply(lambda x: any(k in str(x) for k in exclude_keywords))]

                    # Ensure we have both Inflow and Outflow
                    top_inflow = df_ths.sort_values(by='net_flow_billion', ascending=False).head(10)
                    top_outflow = df_ths.sort_values(by='net_flow_billion', ascending=True).head(10)

                    # Rename columns to match expected output for prompt generator
                    return top_inflow, top_outflow, 'åç§°', 'net_flow_billion'

        except Exception as e:
            print(f"THS source failed: {e}")
            df_ths = None # Ensure df_ths is cleared if it failed

        # --- Fallback to EastMoney if THS fails ---
        print("å°è¯•æ•°æ®æº: ä¸œæ–¹è´¢å¯Œ (EastMoney)...")
        df_em = None
        for i in range(2): # Reduced retries for EM
            try:
                df_em = ak.stock_sector_fund_flow_rank(indicator='ä»Šæ—¥', sector_type=sector_type)
                if df_em is not None and not df_em.empty:
                     data_source = "EM"
                     break
            except Exception as e:
                print(f"å°è¯• {i+1}/2 å¤±è´¥: {e}")
                time.sleep(1)

        if df_em is None or df_em.empty:
            print("å°è¯•æ•°æ®æº: ä¸œæ–¹è´¢å¯Œ (DataAPI)...")
            try:
                df_dataapi = _fetch_sector_flow_dataapi(sector_type)
            except Exception as e:
                print(f"DataAPI source failed: {e}")
                df_dataapi = None

            if df_dataapi is None or df_dataapi.empty:
                print(f"âŒ æœ€ç»ˆè·å– {sector_type} å¤±è´¥ (THS/EM/DataAPIå‡å¤±è´¥)")
                return None

            # --- Filtering Noise / Garbage Names ---
            exclude_keywords = [
                "åŒèŠ±é¡º", "æ¿å—", "æ¦‚å¿µ", "æˆåˆ†", "æŒè‚¡", "è‚¡é€š", "åŸºé‡‘", "æ˜¨æ—¥", "äººæ°‘å¸",
                "èèµ„", "èåˆ¸", "Bè‚¡", "ST", "è½¬å€º", "é«˜è‚¡æ¯", "ç ´å‡€", "ç™¾å…ƒ", "æ ¸å¿ƒ",
                "é¾™å¤´", "èŒ…", "å¤§ç›˜", "ä¸­å­—å¤´", "AH", "REITs", "ETF", "æ ‡å‡†", "æ™®å°”", "MSCI"
            ]
            df_dataapi = df_dataapi[
                ~df_dataapi["åç§°"].apply(lambda x: any(k in str(x) for k in exclude_keywords))
            ]
            top_inflow = df_dataapi.sort_values(by='net_flow_billion', ascending=False).head(10)
            top_outflow = df_dataapi.sort_values(by='net_flow_billion', ascending=True).head(10)
            return top_inflow, top_outflow, 'åç§°', 'net_flow_billion'

        # Process EastMoney data if it was successfully retrieved
        target_col = None
        name_col = None

        # ä¼˜å…ˆå¯»æ‰¾ "ä¸»åŠ›å‡€æµå…¥"
        for col in df_em.columns:
            if "ä¸»åŠ›" in col and "å‡€æµå…¥" in col and "å‡€é¢" in col:
                target_col = col
                break

        # Fallback
        if not target_col:
             for col in df_em.columns:
                if "å‡€æµå…¥" in col and "å‡€é¢" in col and "ä»Šæ—¥" in col:
                    target_col = col
                    break

        for col in df_em.columns:
             if "åç§°" in col:
                name_col = col
                break

        if not target_col or not name_col:
            print(f"âŒ ä¸œæ–¹è´¢å¯Œæ•°æ®åˆ—è¯†åˆ«å¤±è´¥: target_col={target_col}, name_col={name_col}")
            return None

        # ç¡®ä¿æ•°å€¼ç±»å‹
        df_em['net_flow_billion'] = pd.to_numeric(df_em[target_col], errors='coerce') / 100000000

        # --- Filtering Noise / Garbage Names ---
        exclude_keywords = [
            "åŒèŠ±é¡º", "æ¿å—", "æ¦‚å¿µ", "æˆåˆ†", "æŒè‚¡", "è‚¡é€š", "åŸºé‡‘", "æ˜¨æ—¥", "äººæ°‘å¸",
            "èèµ„", "èåˆ¸", "Bè‚¡", "ST", "è½¬å€º", "é«˜è‚¡æ¯", "ç ´å‡€", "ç™¾å…ƒ", "æ ¸å¿ƒ",
            "é¾™å¤´", "èŒ…", "å¤§ç›˜", "ä¸­å­—å¤´", "AH", "REITs", "ETF", "æ ‡å‡†", "æ™®å°”", "MSCI"
        ]

        # If we have name_col, filter
        df_em = df_em[~df_em[name_col].apply(lambda x: any(k in str(x) for k in exclude_keywords))]

        # æ’åº
        top_inflow = df_em.sort_values(by='net_flow_billion', ascending=False).head(10)
        top_outflow = df_em.sort_values(by='net_flow_billion', ascending=True).head(10)

        return top_inflow, top_outflow, name_col, 'net_flow_billion'

    except Exception as e:
        print(f"è·å– {sector_type} å¤±è´¥: {e}")
        return None


def get_creative_title(top_names):
    """æ ¹æ®Topæ¿å—ç”Ÿæˆç”ŸåŠ¨æ ‡é¢˜"""
    if not top_names:
        return "èµ„é‡‘æ¶Œå…¥"

    # 1. ç»„åˆåˆ¤æ–­ (Combos)
    # é‡‘è
    finance_kw = ['è¯åˆ¸', 'é“¶è¡Œ', 'ä¿é™©', 'å¤šå…ƒé‡‘è']
    fin_count = sum(1 for n in top_names if any(k in n for k in finance_kw))
    if fin_count >= 2:
        return random.choice(["å¤§é‡‘èçˆ†å‘", "é‡‘ä¸‰èƒ–å‘åŠ›", "æƒé‡æ­å°", "é‡‘èç‹‚æ¬¢"])

    # ç§‘æŠ€
    tech_kw = ['åŠå¯¼ä½“', 'è½¯ä»¶', 'è®¡ç®—æœº', 'é€šä¿¡', 'ç”µå­', 'èŠ¯ç‰‡', 'å…‰åˆ»æœº', 'æ¶ˆè´¹ç”µå­']
    tech_count = sum(1 for n in top_names if any(k in n for k in tech_kw))
    if tech_count >= 2:
        return random.choice(["ç§‘æŠ€ç‹‚æ¬¢", "ç¡¬ç§‘æŠ€çªå›´", "ç§‘åˆ›å¤§æ¶¨", "ç®—åŠ›å´›èµ·", "èŠ¯ç«ç‡åŸ"])

    # æ–°èƒ½æº
    new_energy_kw = ['å…‰ä¼', 'ç”µæ± ', 'é£ç”µ', 'èƒ½æºé‡‘å±', 'ç”µç½‘', 'å‚¨èƒ½']
    ne_count = sum(1 for n in top_names if any(k in n for k in new_energy_kw))
    if ne_count >= 2:
        return random.choice(["æ–°èƒ½è½¦é£™è½¦", "ç»¿ç”µç‹‚é£™", "å…‰å‚¨ç››å®´", "èµ›é“è‚¡å›å½’", "ç”µå…‰ç«çŸ³"])

    # åŒ»è¯åŒ»ç–—
    med_kw = ['åŒ»è¯', 'åŒ»ç–—', 'ä¸­è¯', 'ç”Ÿç‰©åˆ¶å“', 'åŒ–å­¦åˆ¶è¯']
    med_count = sum(1 for n in top_names if any(k in n for k in med_kw))
    if med_count >= 2:
        return random.choice(["åŒ»è¯åæ”»", "åƒè¯è¡Œæƒ…", "ææ—æ˜¥æš–", "å¤§å¥åº·èµ·èˆ"])

    # æ¶ˆè´¹
    con_kw = ['é…¿é…’', 'é£Ÿå“', 'æ—…æ¸¸', 'å®¶ç”µ', 'é›¶å”®', 'å•†ä¸šç™¾è´§']
    con_count = sum(1 for n in top_names if any(k in n for k in con_kw))
    if con_count >= 2:
        return random.choice(["å¤§æ¶ˆè´¹å¤è‹", "å–é…’åƒè‚‰", "æ¶ˆè´¹å›æš–", "é†‰ç¾Aè‚¡"])

    # 2. Top 1 å•ä¸€åˆ¤æ–­ (Top 1 Specific)
    first = top_names[0]

    mapping = {
        # å¤§é‡‘è
        "è¯åˆ¸": ["ç‰›å¸‚æ——æ‰‹", "åˆ¸å•†æš´åŠ¨", "æ——æ‰‹æ‰›é¼"],
        "é“¶è¡Œ": ["å¤§è±¡èµ·èˆ", "å®šæµ·ç¥é’ˆ", "é“¶è¡ŒæŠ¤ç›˜"],
        "ä¿é™©": ["é™©èµ„è¿›åœº", "è“ç­¹æ ¸å¿ƒ"],
        "å¤šå…ƒé‡‘è": ["é‡‘èæ´»è·ƒ", "é‡‘æ§å‘åŠ›"],

        # æ ¸å¿ƒç§‘æŠ€
        "åŠå¯¼ä½“": ["èŠ¯ç«ç‡åŸ", "å›½äº§ä¹‹å…‰", "ç¼ºèŠ¯æ¶¨ä»·"],
        "èŠ¯ç‰‡": ["èŠ¯ç«ç‡åŸ", "å›½äº§ä¹‹å…‰"],
        "è½¯ä»¶": ["è½¯ä»¶å®šä¹‰", "ä¿¡åˆ›å´›èµ·", "æ•°å­—åº•åº§"],
        "è®¡ç®—æœº": ["ç®—åŠ›ä¸ºç‹", "AIé£å£", "æ•°å­—ç»æµ"],
        "é€šä¿¡": ["5Gå…ˆé”‹", "ä¿¡æ¯é«˜é€Ÿ", "äº‘ç½‘èåˆ"],
        "ç”µå­": ["ç”µå­ç‹‚æ½®", "ç¡¬ä»¶å¤è‹"],
        "æ¶ˆè´¹ç”µå­": ["æœé“¾åå¼¹", "æ¶ˆè´¹å¤è‹"],
        "å…‰åˆ»æœº": ["çªç ´å°é”", "å…‰åˆ»æœºé­‚"],
        "PCB": ["ç”µå­ä¹‹æ¯", "ç¡¬æ¿å´›èµ·"],

        # æ–°èƒ½æº/èµ›é“
        "å…‰ä¼": ["å…‰èŠ’ä¸‡ä¸ˆ", "è¿½å…‰é€æ—¥", "å…‰ä¼åè½¬"],
        "ç”µæ± ": ["èƒ½åŠ¨æœªæ¥", "é”‚æƒ³ä¸»ä¹‰", "ç”µæ± é©å‘½"],
        "èƒ½æºé‡‘å±": ["é”‚é’´é½é£", "èµ„æºä¸ºç‹"],
        "é£ç”µ": ["å¾¡é£è€Œè¡Œ", "é£ç”µæŠ¢è£…"],
        "ç”µç½‘": ["ç‰¹é«˜å‹èµ·", "ç”µç½‘å‡çº§"],

        # å¤§æ¶ˆè´¹
        "é…¿é…’": ["æŠŠé…’è¨€æ¬¢", "é†‰ç¾Aè‚¡", "å–é…’åƒè¯"],
        "é£Ÿå“": ["èˆŒå°–ç¾å‘³", "åƒå–è¡Œæƒ…"],
        "å®¶ç”µ": ["æ™ºèƒ½å®¶å±…", "å®¶ç”µä¸‹ä¹¡"],
        "æ—…æ¸¸": ["è¯—ä¸è¿œæ–¹", "æŠ¥å¤æ¶ˆè´¹"],
        "èˆªç©º": ["èµ·é£æ—¶åˆ»", "äº‘ç«¯æ¼«æ­¥"],
        "é…’åº—": ["å¤è‹å…ˆé”‹", "å‡ºè¡Œå›æš–"],
        "å½±è§†": ["ç¥¨æˆ¿å¤§å–", "å¨±ä¹è‡³ä¸Š"],
        "æ¸¸æˆ": ["ç©èµšä¸–ç•Œ", "å…ƒå®‡å®™é£å£"],
        "æ±½è½¦": ["æé€Ÿç‹‚é£™", "å¼¯é“è¶…è½¦"],

        # åŒ»è¯åŒ»ç–—
        "åŒ»è¯": ["è¯ç¥å½’æ¥", "å¥åº·ä¸­å›½"],
        "åŒ»ç–—": ["å™¨æ¢°çªå›´", "åŒ»ç–—æ–°åŸºå»º"],
        "ä¸­è¯": ["å›½ç²¹ä¼ æ‰¿", "ä¸­è¯ç‘°å®"],
        "ç”Ÿç‰©": ["åˆ›æ–°è¯é­‚", "ç”Ÿç‰©ç§‘æŠ€"],

        # å‘¨æœŸ/èµ„æº
        "çŸ³æ²¹": ["ä¸¤æ¡¶æ²¹", "é»‘é‡‘ç‹‚èˆ"],
        "ç…¤ç‚­": ["ç…¤é£è‰²èˆ", "é»‘é‡‘æ—¶ä»£"],
        "æœ‰è‰²": ["æœ‰è‰²ç‹è€…", "é¡ºå‘¨æœŸ"],
        "é’¢é“": ["é’¢é“æ´ªæµ", "åŸºå»ºè„Šæ¢"],
        "åŒ–å·¥": ["åŒ–å·¥èŒ…èµ·", "æ¶¨ä»·é¢˜æ"],
        "é»„é‡‘": ["é‡‘å…‰é—ªé—ª", "é¿é™©ä¹‹ç‹"],
        "ç¨€åœŸ": ["ç¨€åœŸæ°¸ç£", "å·¥ä¸šç»´ç”Ÿç´ "],

        # åœ°äº§åŸºå»º
        "æˆ¿åœ°äº§": ["é‡‘è¾‰é‡ç°", "åœ°äº§åå¼¹", "ä¿äº¤æ¥¼"],
        "å·¥ç¨‹å»ºè®¾": ["åŸºå»ºç‹‚é­”", "ç¨³å¢é•¿"],
        "æ°´æ³¥": ["å»ºæé¾™å¤´", "æ¶¨ä»·é¢„æœŸ"],
        "å»ºæ": ["åœ°äº§é“¾åŠ¨", "è£…ä¿®æ—ºå­£"],

        # é¢˜ææ¦‚å¿µ
        "ä½ç©ºç»æµ": ["é£è¡Œæ±½è½¦", "ä½ç©ºè…¾é£"],
        "äººå·¥æ™ºèƒ½": ["AIè§‰é†’", "æ™ºé¢†æœªæ¥"],
        "æœºå™¨äºº": ["äººæœºå…±èˆ", "æ™ºèƒ½åˆ¶é€ "],
        "å«æ˜Ÿå¯¼èˆª": ["æ˜Ÿé“¾è®¡åˆ’", "å¤©åœ°äº’è”"],
        "é‡å­ç§‘æŠ€": ["é‡å­çº ç¼ ", "æœªæ¥ç§‘æŠ€"],
        "åä¸º": ["é¥é¥é¢†å…ˆ", "é¸¿è’™ç”Ÿæ€"],
        "æ•°å­—è´§å¸": ["æ•°å­—äººæ°‘å¸", "é‡‘èç§‘æŠ€"],
    }

    # æ¨¡ç³ŠåŒ¹é…
    for key, opts in mapping.items():
        if key in first:
            return random.choice(opts)

    # 3. é€šç”¨å…œåº• (Fallback)
    suffixes = ["é¢†æ¶¨", "çˆ†å‘", "æŠ¢ç­¹", "å´›èµ·", "çªå›´", "å¸é‡‘", "éœ¸æ¦œ", "å¤§æ¶¨"]
    # å–æ¿å—åç®€å†™ (e.g. remove 'è¡Œä¸š')
    short_name = first.replace('è¡Œä¸š', '').replace('æ¦‚å¿µ', '').replace('æ¿å—', '')
    return f"{short_name}{random.choice(suffixes)}"


def generate_prompt(industry_inflow, industry_outflow, output_path="results/sector_flow_image_prompt.txt"):
    """
    Generate AI Prompt in Midjourney/SD format (Based on 20260204 template)
    """
    # Helper: Clean Name
    import re
    def clean_sector_name(raw_name):
        match = re.search(r'\((.*?)\)', raw_name)
        if match:
            inner = match.group(1).strip()
            if inner: return inner
        cleaned = raw_name.replace("æ¦‚å¿µ", "").replace("æ¿å—", "").replace("è¡Œä¸š", "")
        return cleaned.strip()

    # Creative Title
    top_names_for_title = list(industry_inflow.head(3)['åç§°'])
    selected_title = get_creative_title(top_names_for_title)

    # Get top 3 inflow for giants
    top3_in = industry_inflow.head(3)
    giant_entries = []
    for idx, (_, row) in enumerate(top3_in.iterrows()):
        val = float(row['net_flow_billion'])
        c_name = clean_sector_name(row['åç§°'])
        giant_entries.append((c_name, val))

    # Get top 10 outflow for worshippers
    top10_out = industry_outflow.head(10)
    worshipper_labels = []
    for _, row in top10_out.iterrows():
        val = float(row['net_flow_billion'])
        c_name = clean_sector_name(row['åç§°'])
        worshipper_labels.append(f"{c_name} ({val:.1f}äº¿)")

    # Prepare summary for content details
    top5_in = industry_inflow.head(5)
    top5_out = industry_outflow.head(5)

    inflow_summary = ", ".join([f"{i+1}. {clean_sector_name(row['åç§°'])} (+{row['net_flow_billion']:.1f}äº¿)"
                                 for i, (_, row) in enumerate(top5_in.iterrows())])
    outflow_summary = ", ".join([f"{i+1}. {clean_sector_name(row['åç§°'])} ({row['net_flow_billion']:.1f}äº¿)"
                                  for i, (_, row) in enumerate(top5_out.iterrows())])

    # Build the prompt in correct Midjourney/SD format
    prompt_content = f"""(masterpiece, best quality), (vertical:1.2), (aspect ratio: 10:16), (hand drawn), (illustration), (vintage style), (surrealism)

**SUBJECT**: A surreal conceptual illustration with CLEAR TEXT.

**HEADER TEXT**:
- At the top of the image, elegantly integrate the text "**{selected_title}**".
- **Font Style**: **Artistic Chinese Calligraphy** (But CLEAR and LEGIBLE).
- **BACKGROUND for Text**: Place the text on a **Red Ink Grunge** or **Paint Brush Stroke** background.
- **Text Color**: **Gold or White**, High Contrast for readability.

1. **THE GIANTS (Top Inflow Sectors)**:
   Three COLOSSAL, SYMBOLIC MONUMENTS towering in the center. (NON-HUMANOID)
   - **CENTER**: Object for **"{giant_entries[0][0]}"**. Label: "**{giant_entries[0][0]}**" (Black Bold Ink) & "+{giant_entries[0][1]:.1f}äº¿" (Red).
   - **LEFT**: Object for **"{giant_entries[1][0]}"**. Label: "**{giant_entries[1][0]}**" (Black Bold) & "+{giant_entries[1][1]:.1f}äº¿".
   - **RIGHT**: Object for **"{giant_entries[2][0]}"**. Label: "**{giant_entries[2][0]}**" (Black Bold) & "+{giant_entries[2][1]:.1f}äº¿".

2. **THE WORSHIPPERS (Top Outflow Sectors)**:
   In the **FOREGROUND**, a group of **LARGE** figures (pilgrims) with their backs facing the viewer.
   - **POSES**: **Varying kneeling and bowing poses**. Some slumped forward, some upright, some prostrate. **Chaotic and non-uniform arrangement**.
   - **BACK LABELS**: The text on their backs must be **LARGE, CLEAR and LEGIBLE**.
   - **Label Styling**: **Varying Font Sizes**. Larger losses should have **LARGER TEXT**.
   - **Labels**: {", ".join(worshipper_labels)}
   - **Style**: **Hand-written Style but Clean**.
   - **TEXT COLOR - Name**: **Bright Glowing White** (High Visibility).
   - **TEXT COLOR - Number**: **Light Green / Pastel Green** (Clear distinction).
   - **Text Quality**: (perfect text:1.4), (correct chinese characters:1.2).

**ART STYLE**:
- **Vintage Hand-drawn Illustration**: Warm paper texture background, ink lines, watercolor washes.
- **Atmosphere**: Epic, religious scale, slightly dystopian but artistic.
- **Colors**: Sepia, warm brown, faded red (giants), dull green/grey (worshippers).

(Optimized for Nano Banana Pro: Vintage Art Style + Clear Text enforcement)"""

    with open(output_path, "w", encoding='utf-8') as f:
        f.write(prompt_content.strip())

    print(f"âœ… Image Prompt saved to {output_path} (Format: Midjourney/SD)")



def run(date_dir=None):
    """æ¯æ—¥å®šæœŸè¿è¡Œçš„å…¥å£å‡½æ•°"""
    print(f"\n=== Aè‚¡æ¿å—èµ„é‡‘æµå‘ç»Ÿè®¡ ({datetime.now().strftime('%Y-%m-%d')}) ===")

    # 1. è·å–æ•°æ®
    res_industry = get_sector_flow('è¡Œä¸šèµ„é‡‘æµ')
    res_concept = get_sector_flow('æ¦‚å¿µèµ„é‡‘æµ')

    if res_industry or res_concept:
        # 2. æ‰“å°æ–‡æœ¬è¡¨æ ¼
        if res_industry:
            inflow, outflow, name_col, flow_col = res_industry
            print("\\nğŸ† è¡Œä¸šæ¿å— - ä¸»åŠ›å‡€æµå…¥ Top 10")
            for i, (_, row) in enumerate(inflow.iterrows()):
                print(f"{i+1}. {row[name_col]:<10} {row[flow_col]:.2f}äº¿")

            print("\\nğŸ˜­ è¡Œä¸šæ¿å— - ä¸»åŠ›å‡€æµå‡º Top 10")
            for i, (_, row) in enumerate(outflow.iterrows()):
                print(f"{i+1}. {row[name_col]:<10} {row[flow_col]:.2f}äº¿")
        else:
             print("\\nâš ï¸ è¡Œä¸šèµ„é‡‘æµè·å–å¤±è´¥")

        if res_concept:
            print("\\nğŸ† æ¦‚å¿µæ¿å— - ä¸»åŠ›å‡€æµå…¥ Top 10")
            inflow_c, outflow_c, name_col_c, flow_col_c = res_concept
            for i, (_, row) in enumerate(inflow_c.iterrows()):
                print(f"{i+1}. {row[name_col_c]:<10} {row[flow_col_c]:.2f}äº¿")
        else:
            print("\\nâš ï¸ æ¦‚å¿µèµ„é‡‘æµè·å–å¤±è´¥")

        # 3. ç¡®å®šè¾“å‡ºè·¯å¾„
        if date_dir:
            prompt_dir = os.path.join(date_dir, "AIæç¤ºè¯")
            if not os.path.exists(prompt_dir):
                os.makedirs(prompt_dir, exist_ok=True)
            prompt_path = os.path.join(prompt_dir, "èµ„é‡‘æµå‘_Prompt.txt")
        else:
            # é»˜è®¤è·¯å¾„: è‡ªåŠ¨è·å–ä»Šæ—¥æ—¥æœŸ
            today_dir = datetime.now().strftime('%Y%m%d')
            prompt_dir = os.path.join("results", today_dir, "AIæç¤ºè¯")
            if not os.path.exists(prompt_dir):
                os.makedirs(prompt_dir, exist_ok=True)
            prompt_path = os.path.join(prompt_dir, "èµ„é‡‘æµå‘_Prompt.txt")

        # 4. ç”Ÿæˆæç¤ºè¯ (Prioritize Industry data for "Real Sector" visualization)
        if res_industry:
             inflow, outflow, name_col, flow_col = res_industry

             # Draw the Chart
             if date_dir:
                 draw_sector_chart(inflow, outflow, name_col, flow_col, date_dir)
             else:
                 # Fallback to current date dir if not provided
                 today_dir = datetime.now().strftime('%Y%m%d')
                 out_dir = os.path.join("results", today_dir)
                 draw_sector_chart(inflow, outflow, name_col, flow_col, out_dir)

             generate_prompt(inflow, outflow, output_path=prompt_path)
             print("âœ… æ¿å—èµ„é‡‘æµåˆ†æå·²å®Œæˆ (ä½¿ç”¨è¡Œä¸šæ•°æ®ç”Ÿæˆæç¤ºè¯)")
             # Also print fallback Concept if available? No, focus strictly on industry as primary.
             return True

        elif res_concept:
             # Use Concept data as fallback
             inflow_c, outflow_c, name_col_c, flow_col_c = res_concept

             # Draw the Chart (Concept)
             if date_dir:
                 draw_sector_chart(inflow_c, outflow_c, name_col_c, flow_col_c, date_dir)
             else:
                 today_dir = datetime.now().strftime('%Y%m%d')
                 out_dir = os.path.join("results", today_dir)
                 draw_sector_chart(inflow_c, outflow_c, name_col_c, flow_col_c, out_dir)

             generate_prompt(inflow_c, outflow_c, output_path=prompt_path)
             print("âœ… æ¿å—èµ„é‡‘æµåˆ†æå·²å®Œæˆ (ä½¿ç”¨æ¦‚å¿µæ•°æ®ç”Ÿæˆæç¤ºè¯)")
             return True

        return False
    else:
        print("âš ï¸ æ•°æ®(è¡Œä¸š/æ¦‚å¿µ)å‡è·å–å¤±è´¥ï¼Œè·³è¿‡æ¿å—åˆ†æ")
        return False


if __name__ == "__main__":
    run()
